<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Map</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.11.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.11.0/mapbox-gl.js"></script>
  <link rel="stylesheet" href="style.css">
  <style>
    /* Limit popup height and make it scrollable */
    .my-custom-popup .mapboxgl-popup-content {
      max-height: 250px;
      overflow-y: auto;
    }
  </style>
</head>
<body class="interface-page">
  <!-- Header Section -->
  <header class="fixed-header">
    <div class="header-container">
      <a href="interface.html" style="text-decoration: none; color: inherit;">
        <h1>
          <img src="assets/marker_logo-02.png" alt="Logo" style="width:80px; vertical-align:middle; margin-right:10px;">
          When Text Meets Map
        </h1>
      </a>
      <a href="about.html">About</a>
    </div>
  </header>

  <!-- Main Interface Container -->
  <div class="interface_container">
    <!-- Data Input Section -->
    <div class="data-input">
      <p>Literature as Data</p>
      <h2>Data Input</h2>
      <form action="/upload" method="POST" enctype="multipart/form-data">
        <p>On the Road by Jack Kerouac</p>
        <p>Walden by Henry David Thoreau</p>
        <p>Into the Wild by Jon Krakauer</p>
      </form>
      
      <!-- Category Filters -->
      <div class="categories-filter">
        <h2>Filter Categories</h2>
        <div class="filters">
          <div><label><input type="checkbox" id="filter-bus" checked> Bus</label></div>
          <div><label><input type="checkbox" id="filter-river" checked> River</label></div>
          <div><label><input type="checkbox" id="filter-mountain" checked> Mountain</label></div>
          <div><label><input type="checkbox" id="filter-wilderness" checked> Wilderness</label></div>
          <div><label><input type="checkbox" id="filter-trail" checked> Trail</label></div>
          <div><label><input type="checkbox" id="filter-lake" checked> Lake</label></div>
          <div><label><input type="checkbox" id="filter-forest" checked> Forest</label></div>
          <div><label><input type="checkbox" id="filter-desert" checked> Desert</label></div>
          <div><label><input type="checkbox" id="filter-road" checked> Road</label></div>
          <div><label><input type="checkbox" id="filter-camp" checked> Camp</label></div>
          <div><label><input type="checkbox" id="filter-none"> None</label></div>
        </div>
      </div>
      
    </div>
    <!-- Map Section -->
    <div class="map-section">
      <div id="map" style="height: 100%; width: 100%;"></div>
    </div>
  </div>

  <!-- Inline Script: Map Initialization -->
  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoiZGFpc2lzc2llIiwiYSI6ImNtN2Nyb2F3bzB2N3gyam9zenUyamV4eXIifQ.zfJE3IoB71zY8FesqhERag';
    const map = new mapboxgl.Map({
      container: 'map',
      // Using the Mapbox Light style that supports hillshading addition
      style: 'mapbox://styles/daisissie/cm9giyxae00em01qpbxgwbngl',
      minZoom: 3,
      maxBounds: [
        [-171, 15],
        [-47, 72]
      ]
    });

    // Create a single popup instance to reuse on each click
    const popup = new mapboxgl.Popup({
      className: 'my-custom-popup',
      closeOnClick: true,
      maxWidth: '400px'
    });

    map.on('load', () => {
      // Add DEM source
      map.addSource('dem', {
        type: 'raster-dem',
        url: 'mapbox://mapbox.mapbox-terrain-dem-v1'
      });
      // Add hillshade layer below the 'land-structure-polygon' layer
      map.addLayer({
        id: 'hillshading',
        source: 'dem',
        type: 'hillshade',
        paint: {
          'hillshade-shadow-color': '#000000',
          'hillshade-highlight-color': '#777777',
          'hillshade-accent-color': '#555555',
          'hillshade-exaggeration': 1
        }
      }, 'land-structure-polygon');

      // Combined GeoJSON source
      map.addSource('combined', {
        type: 'geojson',
        data: 'geojson_output/output_test.geojson'
      });

      // Load icons for each category
      const categoryIcons = [
        { name: 'bus', url: 'assets/icon-1-01.png' },
        { name: 'river', url: 'assets/icon-1-02.png' },
        { name: 'mountain', url: 'assets/icon-1-03.png' },
        { name: 'wilderness', url: 'assets/icon-1-04.png' },
        { name: 'trail', url: 'assets/icon-1-05.png' },
        { name: 'lake', url: 'assets/icon-1-06.png' },
        { name: 'forest', url: 'assets/icon-1-07.png' },
        { name: 'desert', url: 'assets/icon-1-08.png' },
        { name: 'road', url: 'assets/icon-1-09.png' },
        { name: 'camp', url: 'assets/icon-1-10.png' }
      ];
      categoryIcons.forEach(icon => {
        map.loadImage(icon.url, (error, image) => {
          if (error) throw error;
          map.addImage(`${icon.name}-icon`, image);
        });
      });

      // Combined symbol layer
      map.addLayer({
        id: 'combined-layer',
        type: 'symbol',
        source: 'combined',
        layout: {
          'icon-image': [
            'case',
            ['==', ['get', 'bus', ['get', 'topics']], true], 'bus-icon',
            ['==', ['get', 'river', ['get', 'topics']], true], 'river-icon',
            ['==', ['get', 'mountain', ['get', 'topics']], true], 'mountain-icon',
            ['==', ['get', 'wilderness', ['get', 'topics']], true], 'wilderness-icon',
            ['==', ['get', 'trail', ['get', 'topics']], true], 'trail-icon',
            ['==', ['get', 'lake', ['get', 'topics']], true], 'lake-icon',
            ['==', ['get', 'forest', ['get', 'topics']], true], 'forest-icon',
            ['==', ['get', 'desert', ['get', 'topics']], true], 'desert-icon',
            ['==', ['get', 'road', ['get', 'topics']], true], 'road-icon',
            ['==', ['get', 'camp', ['get', 'topics']], true], 'camp-icon',
            'custom-marker' // fallback icon
          ],
          'icon-size': 0.4,
          'icon-allow-overlap': true
        },
        filter: ['any',
          ['==', ['get', 'bus', ['get', 'topics']], true],
          ['==', ['get', 'river', ['get', 'topics']], true],
          ['==', ['get', 'mountain', ['get', 'topics']], true],
          ['==', ['get', 'wilderness', ['get', 'topics']], true],
          ['==', ['get', 'trail', ['get', 'topics']], true],
          ['==', ['get', 'lake', ['get', 'topics']], true],
          ['==', ['get', 'forest', ['get', 'topics']], true],
          ['==', ['get', 'desert', ['get', 'topics']], true],
          ['==', ['get', 'road', ['get', 'topics']], true],
          ['==', ['get', 'camp', ['get', 'topics']], true]
        ]
      });
      
      updateFilters();

      // Update marker layer logic
      const markerLayers = ['combined-layer'];

      // Add click event listeners for marker layers to display a styled popup
      markerLayers.forEach(layer => {
          map.on('click', layer, function(e) {
              // Gather all features sharing this location name
              const clickedLocation = e.features[0].properties.LocationName || "Unknown Location";
              const featuresAtLocation = map.querySourceFeatures('combined', {
                filter: ['==', ['get', 'LocationName'], clickedLocation]
              });

              // Build HTML entries for each feature at this location
              let entriesHTML = featuresAtLocation.map(f => {
                const ctx = f.properties.context || "No context provided.";
                // Highlight every occurrence of the location name within the context
                const highlightedCtx = ctx.replace(new RegExp(clickedLocation, 'g'), `<mark>${clickedLocation}</mark>`);
                const lit = f.properties.Literature || "No literature info.";
                const sent = f.properties.Sentiment || "No sentiment info.";
                const conf = f.properties.Confidence || "No confidence info.";
                // Compute confidence color
                let confVal = parseFloat(conf);
                let confColor = '#888888';
                if (!isNaN(confVal)) {
                  let ratio = Math.min(Math.max(confVal / 100, 0), 1);
                  let red = Math.round(255 * (1 - ratio));
                  let green = Math.round(255 * ratio);
                  confColor = `rgb(${red},${green},0)`;
                }
                const tops =  JSON.parse(f.properties.topics) || {};
                // Pick only the first true topic, or "None" if none are true
                const firstTopic = Object.keys(tops).find(key => tops[key] === true);
                const category = firstTopic || 'None';
                return `
                  <div class="entry" style="margin-bottom:10px;">
                    <p><strong>Context:</strong> ${highlightedCtx}</p>
                    <p><strong>Literature:</strong> ${lit}</p>
                    <p><strong>Sentiment:</strong> ${sent}</p>
                    <p><strong>Confidence:</strong>
                      <span style="display:inline-block;width:12px;height:12px;background-color:${confColor};margin-right:6px;border:1px solid #000;"></span>
                      ${conf}
                    </p>
                    <p><strong>Category:</strong> ${category}</p>
                  </div>`;
              }).join('');

              // Set popup HTML with aggregated entries
              const popupHTML = `
                  <div class="popup-content">
                    <h2 style="margin: 0 0 8px 0;">${clickedLocation}</h2>
                    ${entriesHTML}
                  </div>`;
              
              // Reuse the same popup instance
              popup
                .setLngLat(e.lngLat)
                .setHTML(popupHTML)
                .addTo(map);
          });
          
          // Change the cursor style when hovering over markers
          map.on('mouseenter', layer, function() {
              map.getCanvas().style.cursor = 'pointer';
          });
          map.on('mouseleave', layer, function() {
              map.getCanvas().style.cursor = '';
          });
      });

      // Category filter controls
      const categories = ['bus','river','mountain','wilderness','trail','lake','forest','desert','road','camp','none'];
      categories.forEach(cat => {
        document.getElementById(`filter-${cat}`).addEventListener('change', updateFilters);
      });
      function updateFilters() {
        const activeCats = categories.filter(cat => document.getElementById(`filter-${cat}`).checked);
        if (activeCats.length === 0) {
          // Hide all if none selected
          map.setFilter('combined-layer', ['in', 'id', '']);
        } else {
          const filterExpr = ['any'];
          activeCats.forEach(cat => {
            if (cat === 'none') {
              // Features with no true topics
              filterExpr.push(['!', ['any',
                ['==', ['get', 'bus', ['get', 'topics']], true],
                ['==', ['get', 'river', ['get', 'topics']], true],
                ['==', ['get', 'mountain', ['get', 'topics']], true],
                ['==', ['get', 'wilderness', ['get', 'topics']], true],
                ['==', ['get', 'trail', ['get', 'topics']], true],
                ['==', ['get', 'lake', ['get', 'topics']], true],
                ['==', ['get', 'forest', ['get', 'topics']], true],
                ['==', ['get', 'desert', ['get', 'topics']], true],
                ['==', ['get', 'road', ['get', 'topics']], true],
                ['==', ['get', 'camp', ['get', 'topics']], true]
              ]]);
            } else {
              filterExpr.push(['==', ['get', cat, ['get', 'topics']], true]);
            }
          });
          map.setFilter('combined-layer', filterExpr);
        }
      }
    });
  </script>

  <!-- External JS File -->
</body>
</html>